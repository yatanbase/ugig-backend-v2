

// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\auth\auth.controller.ts
import { Controller, Post, Body, UseGuards, Request } from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreatePlayerDto } from '../player/dto/create-player.dto'; // Create this DTO
import { LocalAuthGuard } from './local-auth.guard'; // Create this guard
import { AuthGuard } from '@nestjs/passport';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('signup')
  async signup(@Body() createPlayerDto: CreatePlayerDto) {
    await this.authService.signup(createPlayerDto);
    return { message: 'Signup successful!' };
  }

  @UseGuards(LocalAuthGuard) // Use the local strategy for username/password login
  @Post('login')
  async login(@Request() req) {
    return this.authService.login(req.user); // req.user will be populated by the LocalStrategy
  }

  @UseGuards(AuthGuard('jwt')) // Protect this route with JWT
  @Post('profile')
  getProfile(@Request() req) {
    // The user is available in req.user thanks to the JwtStrategy
    return req.user;
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\auth\auth.module.ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller'; // Create this next
import { PlayerModule } from '../player/player.module'; // Create this shortly
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './jwt.strategy'; // We'll create this later
import { TypeOrmModule } from '@nestjs/typeorm';
import { Player } from '../player/player.entity';
import { LocalStrategy } from './local.strategy';

@Module({
  imports: [
    TypeOrmModule.forFeature([Player]),
    PlayerModule,
    PassportModule,
    JwtModule.register({
      secret: 'secret', // Use environment variable
      signOptions: { expiresIn: '1d' }, // Example expiration time
    }),
  ],
  providers: [AuthService, JwtStrategy, LocalStrategy],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\auth\auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { PlayerService } from '../player/player.service';
import { CreatePlayerDto } from 'src/player/dto/create-player.dto';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private playerService: PlayerService,
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async signup(createPlayerDto: CreatePlayerDto) {
    const existingUser = await this.playerService.findOneByEmail(
      createPlayerDto.email,
    );
    if (existingUser) {
      // Throw an exception or return an appropriate error message
      throw new UnauthorizedException('Email is already registered.');
    }

    const existingUserWithUsername = await this.playerService.findOneByUsername(
      createPlayerDto.username,
    );
    if (existingUserWithUsername) {
      // Throw an exception or return an appropriate error message
      throw new UnauthorizedException('Username is already registered.');
    }

    // Hash the password before saving it if the email and username are not already registered

    const user = await this.playerService.create(createPlayerDto);

    // Hashing takes place inside PlayerService.create

    return user;
  }

  async validateUser(username: string, pass: string): Promise<any> {
    const user = await this.playerService.findOneByUsername(username);
    console.log('user in validateUser', user);
    if (!user) {
      return null;
    }

    const isMatch = await bcrypt.compare(pass, user.password);
    if (isMatch) {
      // Exclude the password from the returned user object
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    // const payload = {
    //   username: user.username,
    //   email: user.email,
    //   sub: user.id,
    // };
    // console.log('payload in login service',  'no payload'); // Include user id (sub)
    console.log('jwt in login service', process.env.JWT_SECRET); // Include user id (sub)
    console.log('jwt in login service', this.configService.get('JWT_SECRET')); // Include user id (sub)
    return {
      access_token: this.jwtService.sign(
        {
          username: user.username,
          email: user.email,
          sub: user.id,
        },
        {
          secret: this.configService.get('JWT_SECRET'),
        },
      ),
      username: user.username,
    };
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\auth\jwt.strategy.ts
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PlayerService } from '../player/player.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private playerService: PlayerService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET,
    });
  }

  async validate(payload: any) {
    // payload is the data encoded in the JWT
    const user = await this.playerService.findOneByEmail(payload.email);

    if (!user) {
      throw new UnauthorizedException();
    }

    // The validated user object will be available through request.user
    return user;
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\auth\local-auth.guard.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\auth\local.strategy.ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: 'username' }); // Specify the username field
  }

  async validate(username: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\dto\create-game.dto.ts
export class CreateGameDto {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\dto\update-game.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateGameDto } from './create-game.dto';

export class UpdateGameDto extends PartialType(CreateGameDto) {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\entities\game.entity.ts
// games/game.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  ManyToOne,
  ManyToMany,
  JoinTable,
  OneToMany,
} from 'typeorm';
import { Player } from '../../player/player.entity';
import { Move } from '../../moves/moves.entity';

export enum GameState {
  WAITING = 'waiting',
  IN_PROGRESS = 'in_progress',
  ROUND_OVER = 'round_over',
  GAME_OVER = 'game_over',
  PAUSED = 'paused',
}

@Entity()
export class Game {
  @PrimaryGeneratedColumn()
  gameId: number;

  @Column({
    type: 'enum',
    enum: GameState,
    default: GameState.WAITING,
  })
  state: GameState;

  @ManyToOne(() => Player, (player) => player.wonGames, { nullable: true }) // Assuming Player entity has wonGames field
  winnerPlayer: Player | null; // Optional: Winner of the game

  @ManyToMany(() => Player, (player) => player.games)
  @JoinTable() // Creates a join table automatically
  players: Player[];

  @OneToMany(() => Move, (move) => move.game)
  moves: Move[];

  //Consider adding array if winner can have more than one players
  // @Column('simple-array',{nullable: true})
  // winnerPlayerId: number[]; // Storing an array of winner player IDs

  @CreateDateColumn()
  startAt: Date;

  @UpdateDateColumn()
  endAt: Date;

  @DeleteDateColumn({ nullable: true })
  deletedAt: Date;
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\games.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { GamesController } from './games.controller';
import { GamesService } from './games.service';

describe('GamesController', () => {
  let controller: GamesController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [GamesController],
      providers: [GamesService],
    }).compile();

    controller = module.get<GamesController>(GamesController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\games.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { GamesService } from './games.service';
import { CreateGameDto } from './dto/create-game.dto';
import { UpdateGameDto } from './dto/update-game.dto';

@Controller('games')
export class GamesController {
  // constructor(private readonly gamesService: GamesService) {}
  // @Post()
  // create(@Body() createGameDto: CreateGameDto) {
  //   return this.gamesService.create(createGameDto);
  // }
  // @Get()
  // findAll() {
  //   return this.gamesService.findAll();
  // }
  // @Get(':id')
  // findOne(@Param('id') id: string) {
  //   return this.gamesService.findOne(+id);
  // }
  // @Patch(':id')
  // update(@Param('id') id: string, @Body() updateGameDto: UpdateGameDto) {
  //   return this.gamesService.update(+id, updateGameDto);
  // }
  // @Delete(':id')
  // remove(@Param('id') id: string) {
  //   return this.gamesService.remove(+id);
  // }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\games.module.ts
// games/games.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Game } from './entities/game.entity';
import { GamesService } from './games.service';
import { Player } from '../player/player.entity'; // Import Player entity

@Module({
  imports: [TypeOrmModule.forFeature([Game, Player])], // Add Player to forFeature
  providers: [GamesService],
  exports: [GamesService],
})
export class GamesModule {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\games.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { GamesService } from './games.service';

describe('GamesService', () => {
  let service: GamesService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [GamesService],
    }).compile();

    service = module.get<GamesService>(GamesService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\games\games.service.ts
// games/games.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Game, GameState } from './entities/game.entity';
import { Player } from 'src/player/player.entity';
import { In } from 'typeorm';
@Injectable()
export class GamesService {
  constructor(
    @InjectRepository(Game)
    private gameRepository: Repository<Game>,
    @InjectRepository(Player)
    private playerRepository: Repository<Player>,
  ) {}

  async createGame(playerUsernames: string[]): Promise<Game> {
    const players = await this.playerRepository.findBy({
      username: In(playerUsernames),
    });

    if (players.length !== playerUsernames.length) {
      throw new Error('Some players were not found.');
    }

    const newGame = this.gameRepository.create({
      players,
      state: GameState.WAITING,
    }); // Initialize state

    return this.gameRepository.save(newGame);
  }

  async getGame(gameId: number): Promise<Game | undefined> {
    return this.gameRepository.findOne({
      // Use findOne to find by gameId
      where: { gameId },
      relations: ['players', 'winnerPlayer'], // Eagerly load relations
    });
  }

  async updateGameState(gameId: number, state: GameState): Promise<Game> {
    console.log(
      `updateGameState called with gameId: ${gameId}, state: ${state}`,
    );
    const game = await this.getGame(gameId);
    if (!game) {
      console.error(`Game with id ${gameId} not found`);
      throw new Error('Game not found');
    }
    game.state = state;
    const updatedGame = await this.gameRepository.save(game);
    console.log(
      `Game state updated successfully for gameId: ${gameId}, new state: ${state}`,
    );
    return updatedGame;
  }

  async setWinner(gameId: number, winnerUsername: string): Promise<Game> {
    console.log(
      `setWinner called with gameId: ${gameId}, winnerUsername: ${winnerUsername}`,
    );
    const game = await this.getGame(gameId);
    if (!game) {
      console.error(`Game with id ${gameId} not found`);
      throw new Error('Game not found');
    }

    const winnerPlayer = await this.playerRepository.findOneBy({
      username: winnerUsername,
    });
    if (!winnerPlayer) {
      console.error(`Winner player with username ${winnerUsername} not found`);
      throw new Error('Winner player not found');
    }
    game.winnerPlayer = winnerPlayer; // Set the winnerPlayer relation

    const updatedGame = await this.gameRepository.save(game);
    console.log(
      `Winner set successfully for gameId: ${gameId}, winnerUsername: ${winnerUsername}`,
    );
    return updatedGame;
  }
  // In your GamesService (games.service.ts):

  // ... other methods (e.g., for updating game details, finding games by player, etc.)
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\moves\moves.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from 'typeorm';
import { Game } from '../games/entities/game.entity';
import { Player } from '../player/player.entity';

export enum MoveType {
  SELECT = 'select',
  PREDICT = 'predict',
}

@Entity()
export class Move {
  @PrimaryGeneratedColumn()
  moveId: number;

  @ManyToOne(() => Game, (game) => game.moves, { onDelete: 'CASCADE' }) // Important: Cascade deletion
  game: Game;

  @ManyToOne(() => Player, (player) => player.moves)
  player: Player;

  @Column({ nullable: true }) // Only for predictions and when turn is just assigned
  tilePosition: string; // E.g., '0-0', '7-7'

  @Column({
    type: 'enum',
    enum: MoveType,
  })
  type: MoveType;

  @Column({ nullable: true }) // Only for predictions
  isCorrect?: boolean;
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\moves\moves.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Move } from './moves.entity';
import { MovesService } from './moves.service';
import { Player } from 'src/player/player.entity';
import { Game } from 'src/games/entities/game.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Move, Player, Game])],
  providers: [MovesService],
  exports: [MovesService],
})
export class MovesModule {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\moves\moves.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Move, MoveType } from './moves.entity';
import { Game } from '../games/entities/game.entity';
import { Player } from 'src/player/player.entity';

@Injectable()
export class MovesService {
  constructor(
    @InjectRepository(Move)
    private moveRepository: Repository<Move>,
    @InjectRepository(Player) // Inject Player repository
    private playerRepository: Repository<Player>,
    @InjectRepository(Game) // Inject Player repository
    private gameRepository: Repository<Game>,
  ) {}

  async createMove(
    gameId: number,
    playerUsername: string,
    tilePosition: string,
    type: MoveType,
    isCorrect?: boolean,
  ): Promise<Move> {
    const player = await this.playerRepository.findOneBy({
      username: playerUsername,
    });
    const game = await this.gameRepository.findOneBy({ gameId: gameId });

    const newMove = this.moveRepository.create({
      game,
      player,
      tilePosition,
      type,
      isCorrect,
    });
    return this.moveRepository.save(newMove);
  }

  async getMovesByGame(gameId: number): Promise<Move[]> {
    return this.moveRepository.find({
      where: { game: { gameId } },
      relations: ['player'],
    }); // Find by gameId
  }
  async updateMove(moveId: number, updateData: Partial<Move>): Promise<Move> {
    const move = await this.moveRepository.findOneBy({ moveId });
    if (!move) {
      throw new Error('Move not found');
    }
    Object.assign(move, updateData); // Update the move data
    return this.moveRepository.save(move);
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\player\dto\create-player.dto.ts
import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator';

export class CreatePlayerDto {
  @IsNotEmpty()
  @IsString()
  username: string;

  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @IsString()
  @MinLength(6, { message: 'Password must be at least 6 characters' })
  password: string;

  @IsNotEmpty()
  createdAt: Date;

  @IsNotEmpty()
  updatedAt: Date;

  deletedAt: Date | null;
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\player\player.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  ManyToMany,
  JoinTable,
} from 'typeorm';
import { Game } from '../games/entities/game.entity';
import { Move } from '../moves/moves.entity';

@Entity()
export class Player {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  email: string;

  @Column()
  password: string; // Store the hashed password

  @Column({ unique: true })
  username: string;

  @OneToMany(() => Move, (move) => move.player) // Relationship to Move
  moves: Move[];

  @OneToMany(() => Game, (game) => game.winnerPlayer) // One-to-many relationship: A player can win multiple games
  wonGames: Game[];

  @ManyToMany(() => Game, (game) => game.players)
  games: Game[];

  // @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  // createdAt: Date;

  // @Column({
  //   type: 'timestamp',
  //   default: () => 'CURRENT_TIMESTAMP',
  //   onUpdate: 'CURRENT_TIMESTAMP',
  // })
  // updatedAt: Date;

  // @Column({ type: 'timestamp', nullable: true })
  // deletedAt: Date;
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\player\player.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Player } from './player.entity';
import { PlayerService } from './player.service';

@Module({
  imports: [TypeOrmModule.forFeature([Player])],
  providers: [PlayerService],
  exports: [PlayerService, TypeOrmModule], // Export TypeOrmModule to make PlayerRepository available
})
export class PlayerModule {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\player\player.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Player } from './player.entity';
import * as bcrypt from 'bcrypt';

@Injectable()
export class PlayerService {
  constructor(
    @InjectRepository(Player)
    private playerRepository: Repository<Player>,
  ) {}

  async create(playerData: Partial<Player>): Promise<Player> {
    const saltOrRounds = 10;
    const hashedPassword = await bcrypt.hash(playerData.password, saltOrRounds);

    const newPlayer = this.playerRepository.create({
      ...playerData,
      password: hashedPassword,
    });
    return this.playerRepository.save(newPlayer);
  }

  async findOneByEmail(email: string): Promise<Player | undefined> {
    return this.playerRepository.findOneBy({ email });
  }

  async findOneByUsername(username: string): Promise<Player | undefined> {
    return this.playerRepository.findOneBy({ username });
  }

  // ...other methods for updating, deleting, etc.
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\app.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\app.module.ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { JwtModule } from '@nestjs/jwt';
import { AppService } from './app.service';
import { ConfigModule, ConfigService } from '@nestjs/config';

import { TypeOrmModule } from '@nestjs/typeorm';
import { GameGateway } from './game.gateway';
import { AuthModule } from './auth/auth.module'; // Correctly import AuthModule
import { Player } from './player/player.entity';
import { PlayerService } from './player/player.service';
import { GamesModule } from './games/games.module';
import { PlayerModule } from './player/player.module'; // Import PlayerModule
import { Game } from './games/entities/game.entity';

import { GamesService } from './games/games.service';
import { Move } from './moves/moves.entity';
import { MovesModule } from './moves/moves.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        url: configService.get<string>('DATABASE_URL'),
        entities: [Player, Game, Move],
        synchronize: true,
        emitDecoratorMetadata: true,
      }),

      inject: [ConfigService],
    }),
    TypeOrmModule.forFeature([Player, Game, Move]),
    AuthModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '1d' },
    }),
    GamesModule,
    PlayerModule,
    MovesModule,
  ],

  controllers: [AppController],
  providers: [AppService, GameGateway, PlayerService],
})
export class AppModule {}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\app.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\game.gateway.ts
// game.gateway.ts
import {
  SubscribeMessage,
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
  MessageBody,
} from '@nestjs/websockets';
import { JwtService } from '@nestjs/jwt'; // Import JwtService
import { GamesService } from './games/games.service';
import { Server, Socket } from 'socket.io';
import { MoveType } from './moves/moves.entity';
import { MovesService } from './moves/moves.service';
import { In, Repository } from 'typeorm';
import { Player } from './player/player.entity'; //create this entity
import { InjectRepository } from '@nestjs/typeorm';
import { GameState } from './games/entities/game.entity'; // Import GameState

@WebSocketGateway({
  cors: {
    origin: '*', // Adjust for production
  },
  namespace: 'game',
})
export class GameGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server;
  constructor(
    private readonly jwtService: JwtService,
    private readonly gamesService: GamesService,
    private readonly movesService: MovesService, // Inject
    @InjectRepository(Player)
    private playerRepository: Repository<Player>, // Inject Player repository
  ) {
    console.log(' server instance in GameGateway', this.server);
  }
  private onlineUsers: Set<string> = new Set(); // Back to Set for simplicity
  private userSockets = new Map<string, Socket>(); // Map to store user sockets

  afterInit(server: Server) {
    console.log('Server initialized. Clearing online users list.');
    this.onlineUsers.clear(); // Clear the onlineUsers Set when the server starts
    this.userSockets.clear(); // Clear the userSockets Map when the server starts
    this.emitUserList(); //Emit an empty user list to any connected clients immediately after server start
  }

  async handleConnection(client: Socket) {
    try {
      // Get and verify JWT from connection headers
      // console.log('client', client);
      console.log('jwt secret', process.env.JWT_SECRET);
      const token = client.handshake.headers.authorization?.split(' ')[1]; // "Bearer <token>"
      console.log('token', token);
      const decoded = this.jwtService.verify(token, {
        secret: 'secret',
      });

      console.log('here', decoded);
      if (decoded) {
        // Check if the username already has an active connection
        if (this.userSockets.has(decoded.username)) {
          console.log(
            `Username ${decoded.username} already has an active connection. Disconnecting new client ${client.id}`,
          );
          client.disconnect();
          return;
        }

        // Store username if JWT is valid and no active connection exists
        this.userSockets.set(decoded.username, client);
        this.onlineUsers.add(decoded.username);
        console.log(`Client ${client.id} connected as ${decoded.username}`);
        console.log(`Client connected: ${decoded.username}`);

        this.emitUserList();
      }
    } catch (error) {
      // Handle invalid token (disconnect client or other action)
      console.log('invalid token provided by user', error);
      client.disconnect();
    }
  }
  async handleDisconnect(@ConnectedSocket() client: Socket) {
    // Remove user from onlineUsers if present. Use username from JWT if possible.
    if (client.handshake.headers.authorization) {
      try {
        const token = client.handshake.headers.authorization?.split(' ')[1]; // "Bearer <token>"

        const decoded = this.jwtService.verify(token, {
          secret: process.env.JWT_SECRET,
        });

        const roomId = client.data.roomId;
        const gameId = client.data.gameId;
        const opponentSocket = Array.from(this.userSockets.values()).filter(
          (s) => s.id !== client.id && s.rooms.has(roomId),
        );

        const roomSockets = await this.server.in(roomId).fetchSockets();
        console.log('roomSockets', roomSockets);

        roomSockets.forEach((s) => {
          if (s.id !== client.id) {
            console.log('disconnecting other user');
            this.server.to(s.id).emit('gameOver', { winner: s.data.username });
            this.gamesService.updateGameState(gameId, GameState.GAME_OVER);
            this.gamesService.setWinner(gameId, s.data.username);
          }
        });

        console.log(`deleting ${decoded.username} from userSockets`);
        this.userSockets.delete(decoded.username);
        this.onlineUsers.delete(decoded.username);
        console.log(`Client disconnected: ${decoded.username}`);
      } catch (error) {
        console.log('Error during disconnection:', error);
      }
    }

    this.emitUserList();
    console.log(`Client disconnected: ${client.id}`);
  }

  //   @SubscribeMessage('joinGame')
  //   async handleJoinGame(
  //     @ConnectedSocket() client: Socket,
  //     @MessageBody('gameId') gameId: string,
  //   ) {
  //     client.join(gameId);
  //     console.log(`Client ${client.id} joined game: ${gameId}`);
  //     this.onlineUsers.set(client.id, gameId);
  //     this.emitUserList(gameId); // Update and emit the user list upon joining
  //     client.emit('joinedGame', { gameId });
  //   }

  async emitUserList() {
    // const clientsInRoom = await this.server.fetchSockets();
    // const onlineUsersInRoom = clientsInRoom.map((c) => c.id);
    // this.server.emit('updateUserList', onlineUsersInRoom);
    this.server.emit('updateUserList', Array.from(this.onlineUsers));
  }

  @SubscribeMessage('getOnlineUsers')
  getOnlineUsers() {
    // No need for client parameter
    this.emitUserList(); // Emit the general user list to all clients
  }

  @SubscribeMessage('sendInvite')
  handleSendInvite(
    @MessageBody() data: { to: string },
    @ConnectedSocket() client: Socket,
  ) {
    console.log('data', data);
    console.log('client.id', client.id);
    try {
      const token = client.handshake.headers.authorization?.split(' ')[1]; // "Bearer <token>"

      const decoded = this.jwtService.verify(token, {
        secret: process.env.JWT_SECRET,
      });
      if (!decoded) {
        throw new Error('Invalid token');
      }
      // Log the username sending the invite
      const recipientSocket = this.userSockets.get(data.to);
      console.log('Recipient socket:', recipientSocket?.id);
      if (recipientSocket) {
        recipientSocket.emit('receiveInvite', { from: decoded.username });

        client.emit('inviteResponse', {
          // Respond to sender
          success: true,
          message: 'Invite sent successfully',
          to: data.to,
        });

        console.log(`Invite from ${decoded.username} sent to ${data.to}`);
      } else {
        client.emit('inviteResponse', {
          // Respond to sender with error
          success: false,
          message: 'User not found or offline',
          to: data.to,
        });
        console.log(`User ${data.to} not found or offline.`);
      }
    } catch (error) {
      console.error('Error in sendInvite:', error); // Detailed error logging
      client.emit('inviteResponse', {
        success: false,
        message: error.message, // Send specific error message
        to: data.to,
      });
      client.disconnect();
    }
  }

  @SubscribeMessage('acceptInvite')
  async handleAcceptInvite(
    @MessageBody() data: { from: string },
    @ConnectedSocket() client: Socket,
  ) {
    console.log('Accepting invite from:', data.from);
    try {
      const token = client.handshake.headers.authorization?.split(' ')[1];

      const decoded = this.jwtService.verify(token, {
        secret: process.env.JWT_SECRET,
      });

      const roomId = `room-${data.from}-${decoded.username}-${Date.now()}`; // Create unique room ID using usernames and timestamp
      console.log('Room ID created: ', roomId);
      const game = await this.gamesService.createGame([
        data.from,
        decoded.username,
      ]); // Create a game record

      console.log('game created with players ', game.players);
      client.join(roomId);
      client.data.roomId = roomId;
      console.log(
        `User ${decoded.username} with id ${client.id} joined room: ${roomId}`,
      ); // Log with username

      // Set gameId in client data for future reference
      client.data.gameId = game.gameId;

      // Emit 'joinedRoom' to the current client, including gameId
      client.emit('joinedRoom', { roomId, gameId: game.gameId });
      console.log(`joinedRoom sent to ${client.id} `);
      const joinroomrecipientSocket = this.userSockets.get(data.from);
      if (joinroomrecipientSocket) {
        console.log('joinroomrecipientSocket', joinroomrecipientSocket.id);
        client
          .to(joinroomrecipientSocket.id)
          .emit('joinRoom', { roomId, gameId: game.gameId }); // Tell 'from' user to join
        console.log(
          `${joinroomrecipientSocket.id} ko send kiya joinRoom with gameId ${game.gameId} and roomId ${roomId}`,
        );
        return roomId; // Return roomId
      } else {
        // Handle the case where the inviting user is offline.  You might want to
        // send a message back to the accepting user or handle it differently.
        console.log(`User ${data.from} not found or offline.`);
        client.emit('inviteError', { message: 'The other player is offline.' });
        return;
      }
    } catch (error) {
      console.error('Error accepting invite', error);
      client.disconnect();
    }
  }

  @SubscribeMessage('joinRoom')
  async handleJoinRoom(
    @MessageBody() data: { roomId: string; username: string },
    @ConnectedSocket() client: Socket,
  ) {
    try {
      const token = client.handshake.headers.authorization?.split(' ')[1];

      const decoded = this.jwtService.verify(token, {
        secret: process.env.JWT_SECRET,
      });

      const { roomId } = data;
      client.data.username = decoded.username;

      client.join(roomId);
      console.log(`User ${decoded.username} joined room: ${roomId}`); // Log with username

      // const gameId = client.adapter.rooms.get(roomId)?.gameId;
      //For all server instances
      const sockets = await this.server.in(roomId).fetchSockets();
      const gameId = sockets[0].data.gameId;

      console.log('gameId in handleJoin', gameId);
      client.data.gameId = gameId;
      client.emit('joinedRoom', { roomId, gameId });
      client.to(roomId).emit('joinedRoom', { roomId, gameId });

      this.createTurn(roomId, gameId, data.username); // initiate turn after join
      console.log('createTurn called after joinRoom');
    } catch (error) {
      client.disconnect();
    }
  }

  async createTurn(
    roomId: string,
    gameId: number,
    joiningUsername: string, // to create initial turn after joining
    // client: Socket,
  ) {
    console.log(
      `[createTurn] Starting createTurn for roomId: ${roomId}, gameId: ${gameId}, joiningUsername: ${joiningUsername}`,
    );
    const moves = await this.movesService.getMovesByGame(gameId);
    moves.forEach((move) => {
      console.log(
        `[createTurn] Retrieved move for gameId: ${gameId}`,
        move.moveId,
        move.tilePosition,
        move.type,
        move.player.username || 'someplayer',
      );
    });
    let selector: string;
    let predictor: string;
    let disabledCells: string[] = [];
    let scores: Record<string, number> = {};
    let winner: string | null = null;
    let gameOver = false;
    const game = await this.gamesService.getGame(gameId); // Retrieve the game entity

    //  Ensure game is loaded
    if (!game) {
      console.error('Game not found in createTurn');
      return; // Or handle the error appropriately
    }
    if (moves.length === 0) {
      console.log(`[createTurn] First turn for gameId: ${gameId}`);
      // First move: randomly assign selector and predictor
      const players = await this.gamesService
        .getGame(gameId)
        .then((g) => g.players.map((p) => p.username));
      console.log(`[createTurn] Players in gameId: ${gameId}`, players);
      const randomIndex = Math.floor(Math.random() * 2);
      selector = players[randomIndex];
      predictor = players[1 - randomIndex];
      console.log(
        `[createTurn] Randomly assigned selector: ${selector}, predictor: ${predictor} for gameId: ${gameId}`,
      );
      disabledCells = [];
      scores = players.reduce(
        (acc, playerUsername) => {
          // Calculate scores
          acc[playerUsername] = moves.filter(
            (move) =>
              move.player.username === playerUsername && // Filter moves for the current player
              move.type === MoveType.PREDICT && // Only consider prediction moves
              move.isCorrect, // Correct predictions
          ).length;
          return acc;
        },
        {} as Record<string, number>,
      );
      // await this.movesService.createMove(
      //   gameId,
      //   selector,
      //   null,
      //   MoveType.SELECT,
      // );
      // console.log(
      //   `[createTurn] Created initial move for selector: ${selector} in gameId: ${gameId}`,
      // );
    } else {
      console.log(`[createTurn] Subsequent turn for gameId: ${gameId}`);
      // all other turns

      const sortedMoves = moves.sort((a, b) => b.moveId - a.moveId);
      const lastMove = sortedMoves[0]; // Get the most recent move
      console.log(`[createTurn] Last move for gameId: ${gameId}`, lastMove);

      const players = await this.gamesService
        .getGame(gameId)
        .then((g) => g.players.map((p) => p.username));
      console.log(`[createTurn] Players in gameId: ${gameId}`, players);

      selector =
        lastMove.player.username === players[0] ? players[0] : players[1];
      predictor =
        lastMove.player.username === players[0] ? players[1] : players[0];
      console.log(
        `[createTurn] Assigned selector: ${selector}, predictor: ${predictor} for gameId: ${gameId}`,
      );
      scores = players.reduce(
        (acc, playerUsername) => {
          // Calculate scores
          acc[playerUsername] = moves.filter(
            (move) =>
              move.player.username === playerUsername && // Filter moves for the current player
              move.type === MoveType.PREDICT && // Only consider prediction moves
              move.isCorrect, // Correct predictions
          ).length;
          return acc;
        },
        {} as Record<string, number>,
      );
      // await this.movesService.createMove(
      //   gameId,
      //   selector,
      //   null,
      //   MoveType.SELECT,
      // );
      // console.log(
      //   `[createTurn] Created move for selector: ${selector} in gameId: ${gameId}`,
      // );
      disabledCells = moves
        .filter((move) => move.type === 'select')
        .map((move) => move.tilePosition);
      console.log(
        'disabledCells in createTurn fn else part',
        disabledCells,
        // moves,
      );
    }
    const remainingCells = 64 - disabledCells.length;
    console.log('length of remainingCells in createTurn fn', remainingCells);
    const [player1Username, player2Username] = Object.keys(scores);
    console.log(
      'player1Username, player2Username',
      player1Username,
      player2Username,
    );

    const scoreDifference = Math.abs(
      scores[player1Username] - scores[player2Username],
    );
    console.log(
      `scoreDifference between ${player1Username} and ${player2Username}: ${scoreDifference}` ||
        'scoreDifference not calculated',
    );
    if (scoreDifference > remainingCells / 2 + 1) {
      winner =
        scores[player1Username] > scores[player2Username]
          ? player1Username
          : player2Username;
      gameOver = true;

      console.log(
        `[createTurn] in if(diff>rem) Game over for gameId: ${gameId}`,
        `winner: ${winner}`,
        `scores: ${scores}`,
      );
    } else if (remainingCells === 0) {
      winner =
        scores[player1Username] > scores[player2Username]
          ? player1Username
          : player2Username;
      gameOver = true;
      console.log(
        `[createTurn] in if(rem===0) Game over for gameId: ${gameId}`,
        `winner: ${winner}`,
        `scores: ${scores}`,
      );
    }

    if (gameOver) {
      // Update game state and set winner in database
      await this.gamesService.updateGameState(gameId, GameState.GAME_OVER); // Set game state to GAME_OVER
      console.log(`[createTurn] Game over for gameId: ${gameId}`);
      await this.gamesService.setWinner(gameId, winner); // Store the winner in the database
      console.log(`[createTurn] Winner set for gameId: ${gameId}`, winner);
      this.server.to(roomId).emit('gameOver', { winner, scores });
      return; // Don't emit 'turn' event if game is over
    }

    // Emit 'turn' event with roles
    this.server
      .to(roomId)
      .emit('turn', { selector, predictor, gameId, disabledCells, scores });
    console.log(
      `[createTurn] Emitted 'turn' event for roomId: ${roomId}, gameId: ${gameId} with selector: ${selector}, predictor: ${predictor}, disabledCells: ${disabledCells} and scores:`,
      scores,
    );
  }
  @SubscribeMessage('selectCell')
  async handleSelectCell(
    @MessageBody() data: { cell: string; roomId: string; username: string },
    @ConnectedSocket() client: Socket,
  ) {
    try {
      console.log('data in selectCell subscribe', data);
      const token = client.handshake.headers.authorization?.split(' ')[1];
      const decoded = this.jwtService.verify(token, {
        secret: process.env.JWT_SECRET,
      });

      const gameId = client.data.gameId;
      const { cell, roomId, username } = data;
      console.log('gameId in handleSelectCell', gameId);

      // Create selection move
      const move = await this.movesService.createMove(
        gameId,
        username,
        cell,
        MoveType.SELECT,
      );
      // this.updateDisabledCells(roomId, gameId);

      // Emit cell selection to room
      // client.to(roomId).emit('cellSelected', { cell, username });

      // Enable prediction phase
      this.server.to(roomId).emit('enablePrediction', {
        selector: username,
        cell,
        gameId,
      });

      console.log('Selection phase complete, prediction enabled');
    } catch (error) {
      client.disconnect();
    }
  }

  async updateDisabledCells(roomId: string, gameId: number) {
    const moves = await this.movesService.getMovesByGame(gameId);
    const disabledCells = moves
      .filter((move) => move.type === MoveType.SELECT)
      .map((move) => move.tilePosition);
    console.log('disabledCells in updateDisabledCells fn', disabledCells);
    this.server
      .to(roomId)
      .emit('updateDisabledCells', { disabledCells: disabledCells });
  }

  @SubscribeMessage('predictCell')
  async handlePredictCell(
    @MessageBody() data: { cell: string; roomId: string; username: string },
    @ConnectedSocket() client: Socket,
  ) {
    try {
      const gameId = client.data.gameId;

      const { cell, roomId, username } = data;

      const game = await this.gamesService.getGame(gameId);
      const moves = await this.movesService.getMovesByGame(gameId);
      const sortedMoves = moves.sort((a, b) => b.moveId - a.moveId);
      const lastMove = sortedMoves[0]; // Get the last move (selection move)

      // Create prediction move
      const move = await this.movesService.createMove(
        gameId,
        username,
        cell,
        MoveType.PREDICT,
      );

      // Emit prediction to room
      client.to(roomId).emit('cellPredicted', { cell, username });
      // First, find the Player entity using the username:
      // const player = await this.playerRepository.findOneBy({ username });

      // if (!player) {
      //   throw new Error(`Player with username "${username}" not found.`);
      // }
      const isCorrect = lastMove.tilePosition === cell; // Check if prediction is correct
      // ********* SCORE MANAGEMENT ********
      // if (isCorrect) {
      //   console.log('type of game id', typeof gameId, gameId);
      //   const gamePlayer = await this.gamePlayerRepository
      //     .createQueryBuilder('gp') // Alias the GamePlayer table
      //     .innerJoinAndSelect('gp.player', 'player') // Join with Player table
      //     .where('gp.game.gameId = :gameId', { gameId }) // Condition for game
      //     .andWhere('player.username = :username', { username }) // Condition for player
      //     .getOne();
      //   console.log('gamePlayer in handlePredictCell', gamePlayer);
      //   if (gamePlayer) {
      //     gamePlayer.score++;
      //     await this.gamePlayerRepository.save(gamePlayer);

      //     // Emit the updated scores for all players in the game
      //     const gamePlayers =
      //       await this.gamesService.getGamePlayersByGame(gameId);
      //     const updatedScores = gamePlayers.reduce(
      //       (acc, gp) => {
      //         acc[gp.player.username] = gp.score;
      //         return acc;
      //       },
      //       {} as Record<string, number>,
      //     );
      //     console.log('updatedScores in handlePredictCell', updatedScores);
      //     this.server.to(roomId).emit('scoreUpdate', updatedScores);
      //     console.log('Score updated and emitted', updatedScores);
      //   }
      // }
      // ********* END SCORE MANAGEMENT ********

      await this.movesService.updateMove(move.moveId, { isCorrect }); // Update move with isCorrect value. IMPORTANT: You'll need to implement updateMove in moves.service

      // Emit prediction result (correct/incorrect) to the room
      this.server.to(roomId).emit('predictionResult', { username, isCorrect });

      // Create next turn after prediction
      this.createTurn(roomId, gameId, username);

      console.log('Prediction complete, next turn created');
    } catch (error) {
      console.log('error in handlePredictCell', error);
      client.disconnect();
    }
  }
}



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { GameGateway } from './game.gateway'; // Adjust the path as necessary
import 'reflect-metadata';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors({
    origin: process.env.FRONTEND_URL,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  });
  const gameGatewayInstances = app.get(GameGateway);
  console.log('GameGateway Instances:', gameGatewayInstances); // Inspect in console
  await app.listen(process.env.PORT ?? 4000);
}
bootstrap();



// File: \Wisflux\Internship Assignments\ugig v2 draft\ugig-backend-v2\src\typeorm.config.ts
import { DataSource } from 'typeorm';
import { Player } from './player/player.entity'; // We'll create this entity shortly

export default new DataSource({
  type: 'postgres',
  url: process.env.DATABASE_URL,
  synchronize: true, // Only for development; set to false in production
  entities: [Player],
  ssl: {
    rejectUnauthorized: false, // Only for Neon's free tier.  Disable in other environments.
  },
});

